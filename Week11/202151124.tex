\documentclass[11pt]{article}
\usepackage[hmargin=1in,vmargin=1in]{geometry}
\usepackage{xcolor}
\usepackage{amsmath,amssymb,amsfonts,url,sectsty,framed,tcolorbox,framed}
\newcommand{\pf}{{\bf Proof: }}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newcommand{\qed}{\hfill \rule{2mm}{2mm}}
\newtheorem{example}{Example}
\usepackage{tikz}
\usepackage{bm}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\noindent
\rule{\textwidth}{1pt}
\begin{center}
{\bf [CS304] Introduction to Cryptography and Network Security}
\end{center}
Course Instructor: Dr. Dibyendu Roy \hfill Winter 2023-2024\\
Scribed by: Raghav Agiwal (202151124) \hfill Lecture (Week 11)
\\
\rule{\textwidth}{1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%s%%%%%%%%%%%%
%write here


\section{DLP (Discrete Logarithm Problem)}
\begin{itemize}
    \item \textbf{Definition}: The Discrete Logarithm Problem (DLP) states that given a cyclic group $G$ of order $n$ and a generator $\alpha$ of $G$, along with an element $\beta \in G$, the goal is to find an integer $x$ such that $0 \leq x \leq (n-1)$ and $\alpha^x = \beta$.
    \item \textbf{Cyclic Group}: A cyclic group is a group that can be generated by a single element, called a generator. In this context, $G$ is the cyclic group, $\alpha$ is the generator of $G$, and $\beta$ is an element of $G$.
    \item \textbf{Exhaustive Search}: One way to solve the DLP is through exhaustive search. Given $\alpha$, $\beta$, and $n$, you start with $x = 1$ and iterate up to $x = n$, checking each time if $\alpha^x$ equals $\beta$. Once you find a match, you have found the value of $x$. However, this approach has a complexity equal to the size of the group ($n$), which can be inefficient for large groups.
    \item \textbf{Baby-Step Giant-Step Algorithm}: This algorithm provides a more efficient solution to the DLP. It reduces the complexity from $n$ to approximately $\sqrt{n}$. The algorithm works by precomputing a table of $\alpha^i$ for $i = 0$ to $\lfloor \sqrt{n} \rfloor$ (the "baby steps"), and then computing $\beta \cdot (\alpha^{-\sqrt{n}})^j$ for $j = 0$ to $\lfloor \sqrt{n} \rfloor$ (the "giant steps"). By comparing these values, the algorithm can find the discrete logarithm $x$.
\end{itemize}


\subsection{Baby-Step Giant-Step Algorithm}

The Baby-Step Giant-Step Algorithm is a method used to solve the Discrete Logarithm Problem (DLP) in a cyclic group. It provides a more efficient solution compared to the brute-force approach by reducing the time complexity from $O(n)$ to approximately $O(\sqrt{n})$, where $n$ is the order of the cyclic group.

\subsubsection{Algorithm Overview:}

\begin{enumerate}
    \item \textbf{Precomputation (Baby Steps):}
    \begin{itemize}
        \item Generate a table of baby steps by computing and storing the values of $\alpha^i$ for $i = 0, 1, 2, ..., \lfloor \sqrt{n} \rfloor$, where $\alpha$ is the generator of the cyclic group and $n$ is the order of the group.
    \end{itemize}
    
    \item \textbf{Computation (Giant Steps):}
    \begin{itemize}
        \item For each $j = 0, 1, 2, ..., \lfloor \sqrt{n} \rfloor$, compute the giant step: $\beta \cdot (\alpha^{-\sqrt{n}})^j$, where $\beta$ is the given element of the cyclic group for which we want to find the discrete logarithm.
    \end{itemize}
    
    \item \textbf{Search for Match:}
    \begin{itemize}
        \item Compare the values obtained from the giant steps with the precomputed values from the baby steps.
        \item If a match is found, i.e., if $\alpha^i = \beta \cdot (\alpha^{-\sqrt{n}})^j$, then the discrete logarithm $x$ is given by $x = i + j \cdot \sqrt{n}$.
    \end{itemize}
\end{enumerate}

\subsubsection{Detailed Explanation:}

\begin{enumerate}
    \item \textbf{Precomputation (Baby Steps):}
    \begin{itemize}
        \item In this step, we compute a table of baby steps, which consists of powers of the generator $\alpha$.
        \item We compute and store $\alpha^i$ for $i = 0, 1, 2, ..., \lfloor \sqrt{n} \rfloor$ in a table.
        \item This step requires $O(\sqrt{n})$ computations and memory to store the table.
    \end{itemize}
    
    \item \textbf{Computation (Giant Steps):}
    \begin{itemize}
        \item For each $j = 0, 1, 2, ..., \lfloor \sqrt{n} \rfloor$, we compute the giant step.
        \item The giant step is computed as $\beta \cdot (\alpha^{-\sqrt{n}})^j$.
        \item This step requires $O(\sqrt{n})$ computations.
    \end{itemize}
    
    \item \textbf{Search for Match:}
    \begin{itemize}
        \item We compare the values obtained from the giant steps with the precomputed values from the baby steps.
        \item If a match is found, i.e., if $\alpha^i = \beta \cdot (\alpha^{-\sqrt{n}})^j$, then the discrete logarithm $x$ is given by $x = i + j \cdot \sqrt{n}$.
        \item If no match is found, we continue iterating through the giant steps until a match is found or we exhaust all possible values.
    \end{itemize}
\end{enumerate}

\subsubsection{Complexity Analysis:}

The precomputation step requires $O(\sqrt{n})$ computations and memory. The computation step also requires $O(\sqrt{n})$ computations. Therefore, the overall time complexity of the Baby-Step Giant-Step Algorithm is approximately $O(\sqrt{n})$, making it much more efficient than the brute-force approach for large cyclic groups.

\subsubsection{Conclusion:}

The Baby-Step Giant-Step Algorithm provides an efficient solution to the Discrete Logarithm Problem by reducing the time complexity from $O(n)$ to approximately $O(\sqrt{n})$. It is widely used in various cryptographic applications where efficient solutions to the DLP are required.

\section{Diffie-Hellman Key Exchange Protocol}

The Diffie-Hellman key exchange protocol allows two parties to establish a shared secret key over an insecure communication channel without directly exchanging the key. It relies on the difficulty of the discrete logarithm problem for its security.

\subsection{Algorithm Overview:}

\begin{enumerate}
    \item \textbf{Public Parameters Setup:}
    \begin{itemize}
        \item Parties agree on public parameters:
        \begin{itemize}
            \item A large prime number $p$.
            \item A primitive root modulo $p$, denoted as $g$.
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Key Generation:}
    \begin{itemize}
        \item Each party selects a private key: $a$ for Alice and $b$ for Bob. These are randomly chosen integers from the range $[1, p-1]$.
        \item These private keys are kept secret.
    \end{itemize}
    
    \item \textbf{Public Key Exchange:}
    \begin{itemize}
        \item Alice computes her public key $A = g^a \mod p$.
        \item Bob computes his public key $B = g^b \mod p$.
        \item Public keys $A$ and $B$ are exchanged over the insecure channel.
    \end{itemize}
    
    \item \textbf{Secret Key Derivation:}
    \begin{itemize}
        \item Alice computes the shared secret key $K = B^a \mod p$.
        \item Bob computes the shared secret key $K = A^b \mod p$.
        \item Both parties derive the same shared secret key $K$.
    \end{itemize}
\end{enumerate}

\subsection{Security:}

\begin{itemize}
    \item The security relies on the difficulty of the discrete logarithm problem, which is the challenge of finding $x$ in the equation $g^x \mod p = y$.
    \item Without knowledge of $a$ or $b$, an eavesdropper cannot compute the shared secret key $K$.
\end{itemize}

\subsection{Application:}

The Diffie-Hellman key exchange protocol is used in various cryptographic applications, including secure communication protocols like TLS/SSL, SSH, and VPNs.

\subsection{Conclusion:}

Diffie-Hellman key exchange enables secure key establishment between parties over an insecure channel. It offers confidentiality without requiring prior communication or shared secrets. The protocol's security is based on the computational complexity of solving the discrete logarithm problem in finite fields.

\section{ElGamal Encryption}

\subsection{Definition:}
ElGamal encryption is a public-key cryptosystem that allows two parties to communicate securely over an insecure channel. It's named after its inventor, Taher ElGamal, and it's based on the difficulty of solving the discrete logarithm problem in finite fields.

\subsection{Formula:}

\subsubsection{Key Generation:}
\begin{enumerate}
    \item \textbf{Choose Parameters}:
    \begin{itemize}
        \item Select a large prime number \( p \).
        \item Choose a generator \( g \) of a multiplicative group \( G \) modulo \( p \).
    \end{itemize}
    
    \item \textbf{Generate Private Key}:
    \begin{itemize}
        \item Select a random integer \( x \) from the set \( \{1, 2, ..., p-2\} \).
    \end{itemize}
    
    \item \textbf{Compute Public Key}:
    \begin{itemize}
        \item Calculate \( y = g^x \mod p \).
    \end{itemize}
\end{enumerate}

\subsubsection{Encryption:}
\begin{enumerate}
    \item \textbf{Message Encoding}:
    \begin{itemize}
        \item Represent the message \( m \) as an element in \( G \) (often done by converting it into an integer).
    \end{itemize}
    
    \item \textbf{Choose Randomness}:
    \begin{itemize}
        \item Select a random integer \( k \) from the set \( \{1, 2, ..., p-2\} \).
    \end{itemize}
    
    \item \textbf{Compute Ciphertext Components}:
    \begin{itemize}
        \item \( c_1 = g^k \mod p \)
        \item \( c_2 = m \cdot y^k \mod p \)
    \end{itemize}
\end{enumerate}

\subsubsection{Decryption:}
\begin{enumerate}
    \item \textbf{Compute Shared Secret}:
    \begin{itemize}
        \item Calculate \( s = c_1^x \mod p \).
    \end{itemize}
    
    \item \textbf{Decrypt}:
    \begin{itemize}
        \item Compute \( m = c_2 \cdot s^{-1} \mod p \), where \( s^{-1} \) is the modular multiplicative inverse of \( s \) modulo \( p \).
    \end{itemize}
\end{enumerate}

\subsection{Theory:}
\begin{itemize}
    \item \textbf{Discrete Logarithm Problem (DLP)}:
    \begin{itemize}
        \item ElGamal encryption relies on the computational difficulty of solving the discrete logarithm problem.
    \end{itemize}
    
    \item \textbf{Security}:
    \begin{itemize}
        \item The security of ElGamal encryption depends on the size of the prime modulus \( p \) and the choice of generator \( g \).
    \end{itemize}
    
    \item \textbf{Applications}:
    \begin{itemize}
        \item ElGamal encryption is used in various cryptographic protocols such as digital signatures, key exchange, and secure communication over insecure channels.
    \end{itemize}
\end{itemize}

\section{Kerberos}

Kerberos stands as a computer network security protocol designed to validate service requests amid multiple trusted hosts over an untrusted network, such as the internet. Employing secret-key cryptography and a dependable third party, it ensures the authentication of client-server applications and verifies users' identities. The Kerberos framework engages various entities in its operations, fostering secure interactions within network environments.

\begin{itemize}
    \item Ticket Generating Server (TGS)
    \item Authentication Server (AS)
    \item Verifier (V)
\end{itemize}

Using these third parties, the client \(C\) is verified. The course of communication that takes place in authentication is described below.


\subsection{Kerberos Authentication Protocol Communication Flow:}

\subsection*{Client Authentication Request to AS (Authentication Server):}
The client initiates the authentication process by sending its identity (IDc), the identity of the Ticket Granting Server (TGS) (IDTGS), and a timestamp (TS1) to the AS. This request is encrypted using a shared secret key (SKc) between the client and AS.
\textbf{Formula:}
\[
C \rightarrow AS : \text{E}(SKc, [IDc \ || \ IDTGS \ || \ TS1])
\]

\subsection{AS Response to Client (AS to C):}
The AS receives the client's request and generates a session key (SKc,TGS) for further communication between the client and TGS. It then constructs a ticket granting ticket (TGT) containing relevant information such as the client's identity, the TGS's identity, a timestamp (TS2), and a validity period (Lifetime2). This information is encrypted using the shared secret key (SKc) and sent back to the client.
\textbf{Formula:}
\[
AS \rightarrow C : \text{E}(SKc, [SKc,TGS \ || \ IDTGS \ || \ TS2 \ || \ Lifetime2 \ || \ TicketTGS])
\]

\susubbsection{Client Decrypts AS Response and Obtains TGT:}
The client decrypts the response received from the AS using its shared secret key (SKc) and extracts the session key (SKc,TGS) and the TGT.
\textbf{Formula:}
\[
[SKc,TGS, \ IDTGS, \ TS2, \ Lifetime2, \ TicketTGS]
\]

\subsubsection{Client Authentication Request to TGS (Ticket Granting Server):}
The client requests access to a specific service by sending its identity (IDv), the TGT obtained from the AS, and an authenticator encrypted with the session key (SKc,TGS) to the TGS.
\textbf{Formula:}
\[
C \rightarrow TGS : \text{E}(SKc,TGS, [IDv \ || \ TicketTGS \ || \ Authenticatorc])
\]

\subsubsection{TGS Response to Client (TGS to C):}
The TGS receives the client's request, decrypts the TGT using its own secret key (SKTGS), and validates the client's identity. If the client is authenticated, the TGS issues a service ticket (Ticketv) containing relevant information such as the service's identity, a timestamp (TS4), and a validity period. This information is encrypted using the session key (SKc,v) shared between the client and the service.
\textbf{Formula:}
\[
TGS \rightarrow C : \text{E}(SKc,TGS, [SKc,v \ || \ IDv \ || \ TS4 \ || \ Ticketv])
\]

\subsubsection*{Client Decrypts TGS Response and Obtains Service Ticket:}
The client decrypts the response received from the TGS using the session key (SKc,TGS) and obtains the session key (SKc,v) and the service ticket (Ticketv).
\textbf{Formula:}
\[
[SKc,v, \ IDv, \ TS4, \ Ticketv]
\]

\subsubsection*{Client Authentication Request to Verifier (V):}
The client sends the service ticket (Ticketv) and a fresh authenticator encrypted with the session key (SKc,v) to the verifier (V).
\textbf{Formula:}
\[
C \rightarrow V : \text{E}(SKc,v, [Ticketv \ || \ Authenticatorc])
\]

\subsection*{Verifier Response to Client (V to C):}
The verifier decrypts the service ticket (Ticketv) using its own secret key (SKv) and verifies the client's identity using the decrypted authenticator. If the client is authenticated, the verifier sends a response encrypted with the session key (SKc,v) to the client, confirming the authentication.
\textbf{Formula:}
\[
V \rightarrow C : \text{E}(SKc,v, [TS5+1])
\]

\subsection{Conclusion:}
By integrating the provided communication flow with relevant formulas, we can better understand the encryption and decryption processes involved in the Kerberos authentication protocol, ensuring the confidentiality and integrity of communication between entities across an untrusted network.

\end{document}